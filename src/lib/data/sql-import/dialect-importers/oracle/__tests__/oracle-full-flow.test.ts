import { describe, it, expect } from 'vitest';
import { sqlImportToDiagram, detectDatabaseType } from '../../../index';
import { DatabaseType } from '@/lib/domain/database-type';

describe('Oracle Full Flow Tests', () => {
    it('should detect Oracle database type from SQL content', () => {
        const sql = `
            CREATE TABLE employees (
                id NUMBER(10) GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                name VARCHAR2(255) NOT NULL,
                hire_date DATE DEFAULT SYSDATE
            );
        `;

        const detectedType = detectDatabaseType(sql);
        expect(detectedType).toBe(DatabaseType.ORACLE);
    });

    it('should detect Oracle from VARCHAR2 type', () => {
        const sql = `
            CREATE TABLE test (
                id NUMBER(10) PRIMARY KEY,
                name VARCHAR2(100)
            );
        `;

        const detectedType = detectDatabaseType(sql);
        expect(detectedType).toBe(DatabaseType.ORACLE);
    });

    it('should detect Oracle from SYSDATE usage', () => {
        const sql = `
            CREATE TABLE audit_log (
                id INTEGER PRIMARY KEY,
                created_at DATE DEFAULT SYSDATE
            );
        `;

        const detectedType = detectDatabaseType(sql);
        expect(detectedType).toBe(DatabaseType.ORACLE);
    });

    it('should detect Oracle from GENERATED AS IDENTITY', () => {
        const sql = `
            CREATE TABLE products (
                id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                name VARCHAR(100)
            );
        `;

        const detectedType = detectDatabaseType(sql);
        expect(detectedType).toBe(DatabaseType.ORACLE);
    });

    it('should import Oracle SQL to diagram with correct table structure', async () => {
        const sql = `
            CREATE TABLE departments (
                id NUMBER(10) PRIMARY KEY,
                name VARCHAR2(100) NOT NULL,
                budget NUMBER(12, 2)
            );

            CREATE TABLE employees (
                id NUMBER(10) PRIMARY KEY,
                name VARCHAR2(100) NOT NULL,
                department_id NUMBER(10),
                hire_date DATE DEFAULT SYSDATE,
                CONSTRAINT fk_emp_dept FOREIGN KEY (department_id) REFERENCES departments(id)
            );
        `;

        const diagram = await sqlImportToDiagram({
            sqlContent: sql,
            sourceDatabaseType: DatabaseType.ORACLE,
            targetDatabaseType: DatabaseType.ORACLE,
        });

        expect(diagram).toBeDefined();
        expect(diagram.tables).toBeDefined();
        expect(diagram.tables!).toHaveLength(2);
        expect(diagram.relationships).toBeDefined();
        expect(diagram.relationships!).toHaveLength(1);

        // Check table names
        const deptTable = diagram.tables!.find((t) => t.name === 'departments');
        const empTable = diagram.tables!.find((t) => t.name === 'employees');

        expect(deptTable).toBeDefined();
        expect(empTable).toBeDefined();

        // Check fields
        expect(deptTable!.fields).toHaveLength(3);
        expect(empTable!.fields).toHaveLength(4);

        // Check relationship
        expect(diagram.relationships![0].sourceTableId).toBe(deptTable!.id);
        expect(diagram.relationships![0].targetTableId).toBe(empTable!.id);
    });

    it('should handle Oracle with auto-detection when source type is GENERIC', async () => {
        const sql = `
            CREATE TABLE products (
                id NUMBER(10) GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                name VARCHAR2(200) NOT NULL,
                price NUMBER(10, 2) NOT NULL,
                created_at TIMESTAMP DEFAULT SYSTIMESTAMP
            );
        `;

        const diagram = await sqlImportToDiagram({
            sqlContent: sql,
            sourceDatabaseType: DatabaseType.GENERIC,
            targetDatabaseType: DatabaseType.GENERIC,
        });

        expect(diagram).toBeDefined();
        expect(diagram.tables).toBeDefined();
        expect(diagram.tables!).toHaveLength(1);
        expect(diagram.tables![0].name).toBe('products');
        expect(diagram.tables![0].fields).toHaveLength(4);
    });

    it('should import complex Oracle schema with multiple tables and relationships', async () => {
        const sql = `
            -- Categories table
            CREATE TABLE categories (
                id NUMBER(10) PRIMARY KEY,
                name VARCHAR2(100) NOT NULL,
                description CLOB
            );

            -- Products table
            CREATE TABLE products (
                id NUMBER(10) PRIMARY KEY,
                category_id NUMBER(10) NOT NULL,
                name VARCHAR2(200) NOT NULL,
                price NUMBER(10, 2) NOT NULL,
                stock_quantity NUMBER(10) DEFAULT 0
            );

            -- Customers table
            CREATE TABLE customers (
                id NUMBER(10) PRIMARY KEY,
                name VARCHAR2(100) NOT NULL,
                email VARCHAR2(255) UNIQUE,
                phone VARCHAR2(20)
            );

            -- Orders table
            CREATE TABLE orders (
                id NUMBER(10) PRIMARY KEY,
                customer_id NUMBER(10) NOT NULL,
                order_date DATE DEFAULT SYSDATE,
                total_amount NUMBER(12, 2)
            );

            -- Order items table
            CREATE TABLE order_items (
                id NUMBER(10) PRIMARY KEY,
                order_id NUMBER(10) NOT NULL,
                product_id NUMBER(10) NOT NULL,
                quantity NUMBER(10) NOT NULL,
                unit_price NUMBER(10, 2) NOT NULL
            );

            -- Foreign key constraints
            ALTER TABLE products ADD CONSTRAINT fk_prod_cat FOREIGN KEY (category_id) REFERENCES categories(id);
            ALTER TABLE orders ADD CONSTRAINT fk_ord_cust FOREIGN KEY (customer_id) REFERENCES customers(id);
            ALTER TABLE order_items ADD CONSTRAINT fk_oi_order FOREIGN KEY (order_id) REFERENCES orders(id);
            ALTER TABLE order_items ADD CONSTRAINT fk_oi_product FOREIGN KEY (product_id) REFERENCES products(id);

            -- Indexes
            CREATE INDEX idx_products_category ON products(category_id);
            CREATE INDEX idx_orders_customer ON orders(customer_id);
            CREATE INDEX idx_order_items_order ON order_items(order_id);
            CREATE INDEX idx_order_items_product ON order_items(product_id);
        `;

        const diagram = await sqlImportToDiagram({
            sqlContent: sql,
            sourceDatabaseType: DatabaseType.ORACLE,
            targetDatabaseType: DatabaseType.ORACLE,
        });

        expect(diagram).toBeDefined();
        expect(diagram.tables).toBeDefined();
        expect(diagram.tables!).toHaveLength(5);
        expect(diagram.relationships).toBeDefined();
        expect(diagram.relationships!).toHaveLength(4);

        // Verify all tables exist
        expect(
            diagram.tables!.find((t) => t.name === 'categories')
        ).toBeDefined();
        expect(
            diagram.tables!.find((t) => t.name === 'products')
        ).toBeDefined();
        expect(
            diagram.tables!.find((t) => t.name === 'customers')
        ).toBeDefined();
        expect(diagram.tables!.find((t) => t.name === 'orders')).toBeDefined();
        expect(
            diagram.tables!.find((t) => t.name === 'order_items')
        ).toBeDefined();

        // Verify indexes were parsed
        const productsTable = diagram.tables!.find(
            (t) => t.name === 'products'
        );
        expect(productsTable?.indexes?.length).toBeGreaterThanOrEqual(1);
    });

    it('should handle Oracle-specific syntax without errors', async () => {
        const sql = `
            SET DEFINE OFF;
            SPOOL output.log

            CREATE TABLE test_table (
                id NUMBER(10) GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                name VARCHAR2(100) NOT NULL,
                created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
                updated_at DATE DEFAULT SYSDATE
            )
            TABLESPACE users
            STORAGE (INITIAL 64K NEXT 64K);

            CREATE INDEX idx_test_name ON test_table(name)
            TABLESPACE users_idx;

            SPOOL OFF;
        `;

        const diagram = await sqlImportToDiagram({
            sqlContent: sql,
            sourceDatabaseType: DatabaseType.ORACLE,
            targetDatabaseType: DatabaseType.ORACLE,
        });

        expect(diagram).toBeDefined();
        expect(diagram.tables).toBeDefined();
        expect(diagram.tables!).toHaveLength(1);
        expect(diagram.tables![0].name).toBe('test_table');
    });

    it('should preserve field types correctly when target is Oracle', async () => {
        const sql = `
            CREATE TABLE data_preservation_test (
                id NUMBER(10) PRIMARY KEY,
                amount NUMBER(18, 4) NOT NULL,
                description VARCHAR2(500),
                created_at TIMESTAMP,
                is_active NUMBER(1),
                xml_data XMLTYPE,
                binary_data BLOB
            );
        `;

        const diagram = await sqlImportToDiagram({
            sqlContent: sql,
            sourceDatabaseType: DatabaseType.ORACLE,
            targetDatabaseType: DatabaseType.ORACLE,
        });

        expect(diagram).toBeDefined();
        expect(diagram.tables).toBeDefined();
        const fields = diagram.tables![0].fields;

        // Verify types are preserved or mapped appropriately
        expect(fields.find((f) => f.name === 'id')?.type.id).toBeDefined();
        expect(fields.find((f) => f.name === 'amount')?.type.id).toBeDefined();
        expect(
            fields.find((f) => f.name === 'description')?.type.id
        ).toBeDefined();
        expect(
            fields.find((f) => f.name === 'created_at')?.type.id
        ).toBeDefined();
    });
});
